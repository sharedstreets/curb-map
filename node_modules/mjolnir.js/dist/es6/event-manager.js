import { Manager } from './utils/hammer';
import WheelInput from './inputs/wheel-input';
import MoveInput from './inputs/move-input';
import KeyInput from './inputs/key-input';
import ContextmenuInput from './inputs/contextmenu-input';
import EventRegistrar from './utils/event-registrar';
import { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';
var DEFAULT_OPTIONS = {
  events: null,
  recognizers: null,
  recognizerOptions: {},
  Manager,
  touchAction: 'none'
};
export default class EventManager {
  constructor() {
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
    this.events = new Map();
    this._onBasicInput = this._onBasicInput.bind(this);
    this._onOtherEvent = this._onOtherEvent.bind(this);
    this.setElement(element);
    var {
      events
    } = options;

    if (events) {
      this.on(events);
    }
  }

  setElement(element) {
    if (this.element) {
      this.destroy();
    }

    this.element = element;

    if (!element) {
      return;
    }

    var {
      options
    } = this;
    var ManagerClass = options.Manager;
    this.manager = new ManagerClass(element, {
      touchAction: options.touchAction,
      recognizers: options.recognizers || RECOGNIZERS
    }).on('hammer.input', this._onBasicInput);

    if (!options.recognizers) {
      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {
        var recognizer = this.manager.get(name);

        if (recognizer) {
          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {
            recognizer.recognizeWith(otherName);
          });
        }
      });
    }

    for (var recognizerName in options.recognizerOptions) {
      var recognizer = this.manager.get(recognizerName);

      if (recognizer) {
        var recognizerOption = options.recognizerOptions[recognizerName];
        delete recognizerOption.enable;
        recognizer.set(recognizerOption);
      }
    }

    this.wheelInput = new WheelInput(element, this._onOtherEvent, {
      enable: false
    });
    this.moveInput = new MoveInput(element, this._onOtherEvent, {
      enable: false
    });
    this.keyInput = new KeyInput(element, this._onOtherEvent, {
      enable: false
    });
    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
      enable: false
    });

    for (var [eventAlias, eventRegistrar] of this.events) {
      if (!eventRegistrar.isEmpty()) {
        this._toggleRecognizer(eventRegistrar.recognizerName, true);

        this.manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
  }

  destroy() {
    if (this.element) {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.keyInput.destroy();
      this.contextmenuInput.destroy();
      this.manager.destroy();
      this.wheelInput = null;
      this.moveInput = null;
      this.keyInput = null;
      this.contextmenuInput = null;
      this.manager = null;
      this.element = null;
    }
  }

  on(event, handler, srcElement) {
    this._addEventHandler(event, handler, srcElement, false);
  }

  once(event, handler, srcElement) {
    this._addEventHandler(event, handler, srcElement, true);
  }

  off(event, handler) {
    this._removeEventHandler(event, handler);
  }

  _toggleRecognizer(name, enabled) {
    var {
      manager
    } = this;

    if (!manager) {
      return;
    }

    var recognizer = manager.get(name);

    if (recognizer && recognizer.options.enable !== enabled) {
      recognizer.set({
        enable: enabled
      });
      var fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];

      if (fallbackRecognizers && !this.options.recognizers) {
        fallbackRecognizers.forEach(otherName => {
          var otherRecognizer = manager.get(otherName);

          if (enabled) {
            otherRecognizer.requireFailure(name);
            recognizer.dropRequireFailure(otherName);
          } else {
            otherRecognizer.dropRequireFailure(name);
          }
        });
      }
    }

    this.wheelInput.enableEventType(name, enabled);
    this.moveInput.enableEventType(name, enabled);
    this.keyInput.enableEventType(name, enabled);
    this.contextmenuInput.enableEventType(name, enabled);
  }

  _addEventHandler(event, handler, srcElement, once) {
    if (typeof event !== 'string') {
      srcElement = handler;

      for (var eventName in event) {
        this._addEventHandler(eventName, event[eventName], srcElement, once);
      }

      return;
    }

    var {
      manager,
      events
    } = this;
    var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
    var eventRegistrar = events.get(eventAlias);

    if (!eventRegistrar) {
      eventRegistrar = new EventRegistrar(this);
      events.set(eventAlias, eventRegistrar);
      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;

      if (manager) {
        manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }

    this._toggleRecognizer(eventRegistrar.recognizerName, true);

    eventRegistrar.add(event, handler, srcElement, once);
  }

  _removeEventHandler(event, handler) {
    if (typeof event !== 'string') {
      for (var eventName in event) {
        this._removeEventHandler(eventName, event[eventName]);
      }

      return;
    }

    var {
      events
    } = this;
    var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
    var eventRegistrar = events.get(eventAlias);

    if (!eventRegistrar) {
      return;
    }

    eventRegistrar.remove(event, handler);

    if (eventRegistrar.isEmpty()) {
      var {
        recognizerName
      } = eventRegistrar;
      var isRecognizerUsed = false;

      for (var eh of events.values()) {
        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
          isRecognizerUsed = true;
          break;
        }
      }

      if (!isRecognizerUsed) {
        this._toggleRecognizer(recognizerName, false);
      }
    }
  }

  _onBasicInput(event) {
    var {
      srcEvent
    } = event;
    var alias = BASIC_EVENT_ALIASES[srcEvent.type];

    if (alias) {
      this.manager.emit(alias, event);
    }
  }

  _onOtherEvent(event) {
    this.manager.emit(event.type, event);
  }

}
//# sourceMappingURL=event-manager.js.map