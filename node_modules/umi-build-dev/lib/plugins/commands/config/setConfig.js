"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.update = update;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("fs");

  _fs = function _fs() {
    return data;
  };

  return data;
}

function parser() {
  const data = _interopRequireWildcard(require("@babel/parser"));

  parser = function parser() {
    return data;
  };

  return data;
}

function _traverse() {
  const data = _interopRequireDefault(require("@babel/traverse"));

  _traverse = function _traverse() {
    return data;
  };

  return data;
}

function _generator() {
  const data = _interopRequireDefault(require("@babel/generator"));

  _generator = function _generator() {
    return data;
  };

  return data;
}

function _template() {
  const data = _interopRequireDefault(require("@babel/template"));

  _template = function _template() {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function t() {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function _assert() {
    return data;
  };

  return data;
}

function _prettier() {
  const data = _interopRequireDefault(require("prettier"));

  _prettier = function _prettier() {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _default({
  key,
  value,
  file,
  plugin
}) {
  let content = `export default {}`;

  if ((0, _fs().existsSync)(file)) {
    content = (0, _fs().readFileSync)(file, 'utf-8');
  }

  const newContent = update(content, key, value, plugin);
  (0, _fs().writeFileSync)(file, `${newContent}\n`, 'utf-8');
}

function buildExpression(keys, str) {
  if (str.startsWith('{') || str.startsWith('[')) {// do nothing
  } else if (str === 'true' || str === 'false') {// do nothing
  } else {
    str = `'${str}'`;
  }

  let exp = (0, _template().default)(`(${str})`)().expression;
  let i = 0;
  keys = keys.reverse();

  while (i < keys.length) {
    exp = t().objectExpression([t().objectProperty(t().identifier(keys[i]), exp)]);
    i += 1;
  }

  return exp;
}

function getVariableDeclarator(node, path) {
  if (t().isIdentifier(node) && path.scope.hasBinding(node.name)) {
    const bindingNode = path.scope.getBinding(node.name).path.node;

    if (t().isVariableDeclarator(bindingNode)) {
      node = bindingNode.init;
    }
  }

  return node;
}

function findPluginConfig(node, path, plugin) {
  let plugins = node.properties.find(p => {
    return t().isIdentifier(p.key) && p.key.name === 'plugins';
  }).value;
  (0, _assert().default)(plugins, `plugins is not configured.`);
  plugins = getVariableDeclarator(plugins, path);
  (0, _assert().default)(t().isArrayExpression(plugins), `plugins must be array.`);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = plugins.elements.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      let _step$value = _slicedToArray(_step.value, 2),
          index = _step$value[0],
          el = _step$value[1];

      if (t().isStringLiteral(el) && el.value === plugin) {
        el = (0, _template().default)(`(['${plugin}', {}])`)().expression;
        plugins.elements.splice(index, 1, el);
      }

      el = getVariableDeclarator(el, path);

      if (t().isArrayExpression(el) && t().isStringLiteral(el.elements[0]) && el.elements[0].value === plugin) {
        if (!el.elements[1]) {
          el.elements.push((0, _template().default)(`({})`)().expression);
        }

        let config = el.elements[1];
        config = getVariableDeclarator(config, path);
        (0, _assert().default)(t().isObjectExpression(config), `config for ${plugin} is not object`);
        return config;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function update(content, key, value, plugin) {
  const ast = parser().parse(content, {
    sourceType: 'module',
    plugins: ['jsx', 'typescript']
  });
  (0, _traverse().default)(ast, {
    ExportDefaultDeclaration(path) {
      let node = path.node.declaration; // export default {} as IConfig;

      if (node.type === 'TSAsExpression') {
        node = node.expression;
      } // const a;
      // export default a;


      node = getVariableDeclarator(node, path);
      (0, _assert().default)(t().isObjectExpression(node), `config file must export default a Plain Object`);

      if (plugin) {
        node = findPluginConfig(node, path, plugin);
      }

      let _node = node,
          properties = _node.properties;
      let obj = key;

      if (typeof key === 'string') {
        obj = {
          [key]: value
        };
      }

      Object.keys(obj).forEach(key => {
        const value = obj[key];
        const keys = key.split('.');
        let i = 0;
        let ps = properties;

        while (i < keys.length) {
          let hasFound;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = ps[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              const property = _step2.value;

              if (t().isIdentifier(property.key, {
                name: keys[i]
              })) {
                if (i === keys.length - 1 || !t().isObjectExpression(property.value)) {
                  property.value = buildExpression(keys.slice(i + 1), value);
                  return;
                } else {
                  ps = property.value.properties;
                }

                hasFound = true;
                break;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          if (!hasFound) {
            ps.push(t().objectProperty(t().identifier(keys[i]), buildExpression(keys.slice(i + 1), value)));
            break;
          } else {
            i += 1;
          }
        }
      });
    }

  });
  const newCode = (0, _generator().default)(ast, {}).code;
  return _prettier().default.format(newCode, {
    singleQuote: true,
    trailingComma: 'es5',
    printWidth: 100,
    parser: 'typescript'
  });
}