"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.namespace = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

var _util = require("../util");

var _enums = require("../../server/core/enums");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const namespace = 'org.umi.taskManager';
exports.namespace = namespace;
let init = false;
var _default = {
  namespace,
  state: {
    currentProject: {},
    tasks: {},
    // [cwd]: { dev: DevTask, build: BuildTask, ... }
    dbPath: {} // [cwd]: 'dbPath'

  },
  effects: {
    // 初始化 taskManager
    *init({
      payload,
      callback
    }, {
      call,
      put
    }) {
      const currentProject = payload.currentProject,
            getSharedDataDir = payload.getSharedDataDir;

      const _ref = yield (0, _util.callRemote)({
        type: 'plugin/init'
      }),
            taskStates = _ref.states;

      const dir = yield getSharedDataDir();
      yield put({
        type: 'initCurrentProjectState',
        payload: {
          currentProject,
          taskStates,
          dbPath: dir
        }
      });
    },

    // 执行任务
    *exec({
      payload
    }, {
      call
    }) {
      const taskType = payload.taskType,
            args = payload.args,
            env = payload.env;
      yield call(_util.runTask, taskType, args, env);
    },

    // 取消任务
    *cancel({
      payload
    }, {
      call
    }) {
      const taskType = payload.taskType;
      yield call(_util.cancelTask, taskType);
    },

    // 获取任务详情（获取日志时使用 -> 前端不做 log 的存储）
    *getTaskDetail({
      payload
    }, {
      put,
      call
    }) {
      const taskType = payload.taskType,
            callback = payload.callback,
            log = payload.log,
            dbPath = payload.dbPath;
      const result = yield call(_util.getTaskDetail, taskType, log, dbPath);
      callback && callback(result);
      yield put({
        type: 'updateWebpackStats',
        payload: result
      });
    }

  },
  reducers: {
    initCurrentProjectState(state, {
      payload
    }) {
      const currentProject = payload.currentProject,
            taskStates = payload.taskStates,
            dbPath = payload.dbPath;
      return _objectSpread({}, state, {
        currentProject,
        tasks: _objectSpread({}, state.tasks, {
          [currentProject.path]: taskStates
        }),
        dbPath: _objectSpread({}, state.dbPath, {
          [currentProject.path]: dbPath
        })
      });
    },

    updateTaskDetail(state, {
      payload
    }) {
      const taskType = payload.taskType,
            detail = payload.detail,
            cwd = payload.cwd;

      const stats = detail.stats,
            rest = _objectWithoutProperties(detail, ["stats"]);

      return _objectSpread({}, state, {
        tasks: _objectSpread({}, state.tasks, {
          [cwd]: _objectSpread({}, state.tasks[cwd], {
            [taskType]: _objectSpread({}, state.tasks[cwd][taskType], {}, rest, {
              analyze: stats ? new _util.Analyze(stats) : null
            })
          })
        })
      });
    },

    updateWebpackStats(state, {
      payload
    }) {
      const currentCwd = payload.currentCwd,
            stats = payload.stats,
            type = payload.type;
      return _objectSpread({}, state, {
        tasks: _objectSpread({}, state.tasks, {
          [currentCwd]: _objectSpread({}, state.tasks[currentCwd], {
            [type]: _objectSpread({}, state.tasks[currentCwd][type], {
              analyze: stats ? new _util.Analyze(stats) : null // 若有 stats, 初始化 analyze instance

            })
          })
        })
      });
    }

  },
  subscriptions: {
    setup({
      history,
      dispatch
    }) {
      history.listen(({
        pathname
      }) => {
        if (init) {
          return;
        }

        if (pathname === '/tasks') {
          init = true; // 接收状态通知

          (0, _util.listenRemote)({
            type: 'org.umi.task.state',
            onMessage: ({
              detail,
              taskType,
              cwd
            }) => {
              // 更新 state 数据
              dispatch({
                type: 'updateTaskDetail',
                payload: {
                  detail,
                  taskType,
                  cwd
                }
              }); // 成功或者失败的时候做通知

              if ([_enums.TaskState.INIT, _enums.TaskState.ING].indexOf(detail.state) > -1) {
                return;
              }

              const _getNoticeMessage = (0, _util.getNoticeMessage)(taskType, detail.state),
                    title = _getNoticeMessage.title,
                    message = _getNoticeMessage.message,
                    rest = _objectWithoutProperties(_getNoticeMessage, ["title", "message"]); // TODO: 这儿应该加上项目的名称


              (0, _util.notify)(_objectSpread({
                title: (0, _util.intl)({
                  id: title
                }),
                message: (0, _util.intl)({
                  id: message
                })
              }, rest));
            }
          }); // 日志更新

          (0, _util.listenRemote)({
            type: 'org.umi.task.log',
            onMessage: ({
              log = '',
              taskType
            }) => {
              if (!log) {
                return;
              } // TODO: 多项目之间的 terminalIns 是否已经是混用的了？


              (0, _util.getTerminalIns)(taskType).write(log.replace(/\n/g, '\r\n'));
            }
          });
        }
      });
    }

  }
};
exports.default = _default;